{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction First just let me say THANK YOU for purchasing my framework. I built this to make working with UI easier as last time we rewrote our menu screen it took 3 days to code it. With this we did it in just 2 1/2 hours. And I'm sure we will implement more time-saving features as time goes on. By purchasing this system you go that extra mile in allowing me to continue to support this awesome library and make working with your UI that much easier. Some of the images seem small, but if you right click on them and open in a new tab or zoom in you'll be able to see them. Technical stuff The internals use System.Actions which are much faster than UnityEvent<>'s so the update messages to the ui elements are blazing fast. The Controller change-detection for Two-Way binding uses fixed update so the more fields you add to your controller the more the performance hit, however the computation just goes through a list and checks for equality so the performance hit is minimal and probably neglegent for 99% of use-cases. Just be sure to not overload your controllers will functionality, the system was written so that you could modularize your controllers so there's really no need to overload your base controller. This does mean that unfortunately data is doubled up however, Unity compiles down these simple controller classes into structs so the memory impact is minimized. Requirements Unity 2019.4 or Greater UGUI (the default built-in gui) Slight working knowlege of C#, although this documentation will teach you the basics.","title":"Introduction"},{"location":"#introduction","text":"First just let me say THANK YOU for purchasing my framework. I built this to make working with UI easier as last time we rewrote our menu screen it took 3 days to code it. With this we did it in just 2 1/2 hours. And I'm sure we will implement more time-saving features as time goes on. By purchasing this system you go that extra mile in allowing me to continue to support this awesome library and make working with your UI that much easier. Some of the images seem small, but if you right click on them and open in a new tab or zoom in you'll be able to see them.","title":"Introduction"},{"location":"#technical-stuff","text":"The internals use System.Actions which are much faster than UnityEvent<>'s so the update messages to the ui elements are blazing fast. The Controller change-detection for Two-Way binding uses fixed update so the more fields you add to your controller the more the performance hit, however the computation just goes through a list and checks for equality so the performance hit is minimal and probably neglegent for 99% of use-cases. Just be sure to not overload your controllers will functionality, the system was written so that you could modularize your controllers so there's really no need to overload your base controller. This does mean that unfortunately data is doubled up however, Unity compiles down these simple controller classes into structs so the memory impact is minimized.","title":"Technical stuff"},{"location":"#requirements","text":"Unity 2019.4 or Greater UGUI (the default built-in gui) Slight working knowlege of C#, although this documentation will teach you the basics.","title":"Requirements"},{"location":"controllers/","text":"Controllers What is a \"Controller\"? A controller in RAYUI is just a C# script that inherits from RaycastGames.Controller this file is then read by the modifiers to present you with options to bind your UI widgets to. It also handles any clicked or changed callbacks, all bound variables are Two-Way Bound. Example I'm going to show you an example controller first so you can see just how easy it is to write a Controller in RAYUI. using UnityEngine; using RaycastGames; namespace MyGame { public class MyController : Controller { public string MyBoundString = \"\"; public bool MyBoundBool = false; public int MyBoundInt = 1; public float MyBoundFloat = 0.1f; public void MyBoundBoolChanged() { Debug.Log(\"My Bool Changed to: \" + this.MyBoundBool); } public void MyButtonClicked() { Debug.Log(\"Button Clicked\"); } } } Adding a controller to your UI Controllers are powerful! A Controller holds your bound variables and also handles your events from your UI. To add a controller to your UI simply add UIManager as a component to your base canvas entity and then choose where your controller should be. Your controller must be a parent of the UI you want to bind, the modifiers will traverse up and use the first controller they find. This allows you to have multiple controllers in your UI, for our current purposes we are going to apply our MyController Controller to our canvas to act as our base controller. But nothing is stopping us from creating a window UI element, and then putting a controller on the Window element. This would allow you to do things like have your base controller show/hide your inventory window, player equipment window, etc... Then have a sepparate controller for the inventory window functionality. Binding What is \"Binding\" and what does \"Two-Way binding\" even mean? Let's look at a simple example. Let's say you had a TextBox (known as a InputField in Unity) and you wanted to bind it to MyBoundString on our controller. We would use a Ray_model to do this, which you would simply add as a component to your InputField. The Ray_Model will automatically traverse up and use the first Controller it can find, in our case it's on our canvas. (the images will be smaller after this one, I promise) Ok, we see that it's using the MyController script attached to the canvas. Perfect! This is what we expected/wanted, next let's tell it what field we want to observe. Awesome, we see that our Ray_model is using the right Controller and is bound to the correct field. Let's click on Canvas scroll down to our Controller and watch as we type into our input field. (Ok, I lied, this image is HUGE) You can see that when we type into our input field, the field MyBoundString reflects the changes on our MyController component. If you modify the field in the inspector watch the input field and you will see the input field will also change this is why it's known as Two-Way-Binding I'll show you just one of the useful ways to use this in the examples section. If you want a challenge, add a text widget above the input, bound it to MyBoundString with a Ray_Model and you'll see that it changes as you type. You'll be able to see the performance of the binding system this way as well. First though, let's work with our on-changed events. Add a toggle to our canvas and Ray_model bind it to MyBoundBool then add a Ray_on_change component to your input field and set the binding method to MyBoundBoolChanged this method could be named anything but I kept the names as close to the bounded fields as possible to make it easier to understand. Click our canvas element scroll down to our MyController component and run the game, we see that our toggle becomes unchecked immediately. When we check the toggle you'll see that the controller field MyBoundBool updates to checked and then we see in our console \"My Bool Changed to: True\" The changed event execution is delayed by 10 milliseconds to allow the binding updates to take place first. This does not spawn another thread nor does it delay the exectuion of our other game functions so it's safe to use during heavy computations.","title":"Controllers"},{"location":"controllers/#controllers","text":"","title":"Controllers"},{"location":"controllers/#what-is-a-controller","text":"A controller in RAYUI is just a C# script that inherits from RaycastGames.Controller this file is then read by the modifiers to present you with options to bind your UI widgets to. It also handles any clicked or changed callbacks, all bound variables are Two-Way Bound.","title":"What is a \"Controller\"?"},{"location":"controllers/#example","text":"I'm going to show you an example controller first so you can see just how easy it is to write a Controller in RAYUI. using UnityEngine; using RaycastGames; namespace MyGame { public class MyController : Controller { public string MyBoundString = \"\"; public bool MyBoundBool = false; public int MyBoundInt = 1; public float MyBoundFloat = 0.1f; public void MyBoundBoolChanged() { Debug.Log(\"My Bool Changed to: \" + this.MyBoundBool); } public void MyButtonClicked() { Debug.Log(\"Button Clicked\"); } } }","title":"Example"},{"location":"controllers/#adding-a-controller-to-your-ui","text":"Controllers are powerful! A Controller holds your bound variables and also handles your events from your UI. To add a controller to your UI simply add UIManager as a component to your base canvas entity and then choose where your controller should be. Your controller must be a parent of the UI you want to bind, the modifiers will traverse up and use the first controller they find. This allows you to have multiple controllers in your UI, for our current purposes we are going to apply our MyController Controller to our canvas to act as our base controller. But nothing is stopping us from creating a window UI element, and then putting a controller on the Window element. This would allow you to do things like have your base controller show/hide your inventory window, player equipment window, etc... Then have a sepparate controller for the inventory window functionality.","title":"Adding a controller to your UI"},{"location":"controllers/#binding","text":"What is \"Binding\" and what does \"Two-Way binding\" even mean? Let's look at a simple example. Let's say you had a TextBox (known as a InputField in Unity) and you wanted to bind it to MyBoundString on our controller. We would use a Ray_model to do this, which you would simply add as a component to your InputField. The Ray_Model will automatically traverse up and use the first Controller it can find, in our case it's on our canvas. (the images will be smaller after this one, I promise) Ok, we see that it's using the MyController script attached to the canvas. Perfect! This is what we expected/wanted, next let's tell it what field we want to observe. Awesome, we see that our Ray_model is using the right Controller and is bound to the correct field. Let's click on Canvas scroll down to our Controller and watch as we type into our input field. (Ok, I lied, this image is HUGE) You can see that when we type into our input field, the field MyBoundString reflects the changes on our MyController component. If you modify the field in the inspector watch the input field and you will see the input field will also change this is why it's known as Two-Way-Binding I'll show you just one of the useful ways to use this in the examples section. If you want a challenge, add a text widget above the input, bound it to MyBoundString with a Ray_Model and you'll see that it changes as you type. You'll be able to see the performance of the binding system this way as well. First though, let's work with our on-changed events. Add a toggle to our canvas and Ray_model bind it to MyBoundBool then add a Ray_on_change component to your input field and set the binding method to MyBoundBoolChanged this method could be named anything but I kept the names as close to the bounded fields as possible to make it easier to understand. Click our canvas element scroll down to our MyController component and run the game, we see that our toggle becomes unchecked immediately. When we check the toggle you'll see that the controller field MyBoundBool updates to checked and then we see in our console \"My Bool Changed to: True\" The changed event execution is delayed by 10 milliseconds to allow the binding updates to take place first. This does not spawn another thread nor does it delay the exectuion of our other game functions so it's safe to use during heavy computations.","title":"Binding"},{"location":"examples/","text":"Examples Phone number field (example of two-way binding) First, start by creating a input field, TextMeshPro or Default make sure you set the type to integer field. Then add another text field into the Text Area and set it to fill the space. Set the first text entity to 0 font-size and then the new one to whatever seems to fit well. Then, create a panel, put the input field inside of it and create a new controller with this code. ///----------------------------------------------------------------- /// Author : Raycast Games LLC /// Date : 10/23/2020 16:15 ///----------------------------------------------------------------- using System; using System.Collections; using UnityEngine; namespace MyGame { public class PhoneNumberField : Controller { public string PhoneNumber = \"\"; private string MaskedNumber = \"\"; public void NumberChanged() { try{ this.MaskedNumber = String.Format(\"{0:# (###) ###-####}\", Int64.Parse(this.PhoneNumber)); }catch(Exception e) { Debug.Log(e); } } } } Then Put a Ray Model on the input field and bind it to PhoneNumber and put a Ray On Change on the input field as make it call the NumberChanged() method. After that go to the text field you created, and add a Ray Model to it and bind it to the Masked Number field. Now when you run the game, your text field will automagically mask your phone number for you. It's not perfect but if you put a little work into it, you can make it feel like a professional UI widget with little effort.","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#phone-number-field-example-of-two-way-binding","text":"First, start by creating a input field, TextMeshPro or Default make sure you set the type to integer field. Then add another text field into the Text Area and set it to fill the space. Set the first text entity to 0 font-size and then the new one to whatever seems to fit well. Then, create a panel, put the input field inside of it and create a new controller with this code. ///----------------------------------------------------------------- /// Author : Raycast Games LLC /// Date : 10/23/2020 16:15 ///----------------------------------------------------------------- using System; using System.Collections; using UnityEngine; namespace MyGame { public class PhoneNumberField : Controller { public string PhoneNumber = \"\"; private string MaskedNumber = \"\"; public void NumberChanged() { try{ this.MaskedNumber = String.Format(\"{0:# (###) ###-####}\", Int64.Parse(this.PhoneNumber)); }catch(Exception e) { Debug.Log(e); } } } } Then Put a Ray Model on the input field and bind it to PhoneNumber and put a Ray On Change on the input field as make it call the NumberChanged() method. After that go to the text field you created, and add a Ray Model to it and bind it to the Masked Number field. Now when you run the game, your text field will automagically mask your phone number for you. It's not perfect but if you put a little work into it, you can make it feel like a professional UI widget with little effort.","title":"Phone number field (example of two-way binding)"},{"location":"modifiers/","text":"Modifiers There are currently 4 modifiers you can apply to your UI elements. Ray Model Ray Model Two-Way binds your UI element to a fields on your controller. This currently only works on InputFields, Sliders, Toggles and Text however, I plan on supporting DropDowns in the near future. Ray On Change The Ray On Change modifier listens for changes to your UI elements and then calls a method on your controller. This currently only works on InputFields, Sliders and Toggles. I plan on support DropDowns in the near future. Ray On Click The Ray On Change modifier listens for you to click on a button and then calls a method on your controller. This currentl only works on Buttons however I am currently looking for a way to handle any UI element with this. If I get this working, i'll be able to support on-hover and on-leave as well. Ray Show/Hide The Ray Show/Hide modifier pretty much does as it sound, it listens to a bool to see if it's true or false, if true it shows that UI element and if it's false it hides it. (this works even if the UI element is disabled). This also works with Enums which I use to handle the steps for my MMO's main screen to switch through the windows.","title":"Modifiers"},{"location":"modifiers/#modifiers","text":"There are currently 4 modifiers you can apply to your UI elements.","title":"Modifiers"},{"location":"modifiers/#ray-model","text":"Ray Model Two-Way binds your UI element to a fields on your controller. This currently only works on InputFields, Sliders, Toggles and Text however, I plan on supporting DropDowns in the near future.","title":"Ray Model"},{"location":"modifiers/#ray-on-change","text":"The Ray On Change modifier listens for changes to your UI elements and then calls a method on your controller. This currently only works on InputFields, Sliders and Toggles. I plan on support DropDowns in the near future.","title":"Ray On Change"},{"location":"modifiers/#ray-on-click","text":"The Ray On Change modifier listens for you to click on a button and then calls a method on your controller. This currentl only works on Buttons however I am currently looking for a way to handle any UI element with this. If I get this working, i'll be able to support on-hover and on-leave as well.","title":"Ray On Click"},{"location":"modifiers/#ray-showhide","text":"The Ray Show/Hide modifier pretty much does as it sound, it listens to a bool to see if it's true or false, if true it shows that UI element and if it's false it hides it. (this works even if the UI element is disabled). This also works with Enums which I use to handle the steps for my MMO's main screen to switch through the windows.","title":"Ray Show/Hide"}]}